#!/usr/bin/env bash

# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Firecracker rfstool
#
# Use this script to build a rootfs file for testing Firecracker.
#
# TL;DR
# Make sure you have Docker installed and properly configured
# (http://docker.com). Then,
#   building: `./rfstool build`
#     Then find the rootfs file under
#     build/img/local/${HOSTTYPE}/minimal/fsfiles, where HOSTTYPE is the bash
#     variable specifying your host architecture.
#
# Building is done inside a Docker container. Please make sure
# you have Docker up and running on your system (see http:/docker.com) and your
# user has permission to run Docker containers.
#
# The Firecracker sources dir will be bind-mounted inside the development
# container (under /firecracker) and any files generated by the build process
# will show up under the build/img/local/${HOSTTYPE} dir.
#
# By default, all rfstool commands run the container transparently, removing
# it after the command completes. Any persisting files will be stored under
# build/.
#
# Building:
#   Run `./rfstool build`.
#
# Additional information:
#   Run `./rfstool help`.
#
# TODO:
#   - minimal_with_initrd build
#   - ubuntu build
#   - ubuntu_with_ssh build
#   - all build

# Rootfs build container image (name:tag)
# This should be updated whenever we upgrade the rootfs build container.
CTR_IMAGE="fcuvm/rfs:v01"

# Naming things is hard
MY_NAME="Firecracker $(basename "$0")"

# Full path to the Firecracker tools dir on the host.
FC_TOOLS_DIR=$(cd "$(dirname "$0")" && pwd)

# Full path to the Firecracker sources dir on the host.
FC_ROOT_DIR=$(cd "${FC_TOOLS_DIR}/.." && pwd)

# Full path to the build dir on the host.
FC_BUILD_DIR="${FC_ROOT_DIR}/build"

# Full path to the img dir on the host.
FC_IMAGES_DIR="${FC_BUILD_DIR}/img"

# Full path to the Firecracker sources dir, as bind-mounted in the container.
CTR_FC_ROOT_DIR="/firecracker"

# Full path to the build dir, as bind-mounted in the container.
CTR_FC_BUILD_DIR="${CTR_FC_ROOT_DIR}/build"

# Full path to the microVM images cache dir
CTR_MICROVM_IMAGES_DIR="${CTR_FC_BUILD_DIR}/img"

#############################################################
# Alpine OS variables
#############################################################

# Alpine version
RFS_ALPINE_VERS="3.8.1"

# Alpine CDN url
RFS_ALPINE_ORIGIN="http://dl-cdn.alpinelinux.org"

# Alpine package name, url location, and shas.
declare -A RFS_ALPINE=(
    [PACKAGE]="alpine-minirootfs-${RFS_ALPINE_VERS}-${HOSTTYPE}.tar.gz"
    [URL]="${RFS_ALPINE_ORIGIN}"
    [URL]+="/alpine/v${RFS_ALPINE_VERS%.*}/releases/${HOSTTYPE}"
    [URL]+="/${RFS_ALPINE[PACKAGE]}"
    [X86_64_SHA256]="ad753d802048fa902e4d8b35cc53656de8ed0e6d082246089a"
    [X86_64_SHA256]+="11a86014b0f1a5"
    [AARCH64_SHA256]="425be487ecc4bd0333fd84ec8c6c4b971a32446be76df26e7"
    [AARCH64_SHA256]+="add04be95987fa8"
)

#############################################################
# Ubuntu OS variables
#############################################################

# Ubuntu version
RFS_UBUNTU_VERS="18.04"
RFS_UBUNTU_CODE_VERS="bionic"
RFS_UBUNTU_RELEASE="release-20200317"

# Ubuntu CDN url
RFS_UBUNTU_ORIGIN="https://cloud-images.ubuntu.com"

# Ubuntu uses different architecture names
[[ "${HOSTTYPE}" = "x86_64" ]] && RFS_UBUNTU_ARCH=${HOSTTYPE/x86_64/amd64}
[[ "${HOSTTYPE}" = "aarch64" ]] && RFS_UBUNTU_ARCH=${HOSTTYPE/aarch64/arm64}

# Ubuntu package name, url location, and shas.
declare -A RFS_UBUNTU_BIONIC=(
    [PACKAGE]="ubuntu-${RFS_UBUNTU_VERS}-server-cloudimg-"
    [PACKAGE]+="${RFS_UBUNTU_ARCH}-root.tar.xz"
    [URL]="${RFS_UBUNTU_ORIGIN}"
    [URL]+="/releases/${RFS_UBUNTU_CODE_VERS}/${RFS_UBUNTU_RELEASE}"
    [URL]+="/${RFS_UBUNTU_BIONIC[PACKAGE]}"
    [X86_64_SHA256]="b030e1b758b61b5ec53d1b1a38cda6a44b91ff4643d3b493dc3c"
    [X86_64_SHA256]+="605a94d56262"
    [AARCH64_SHA256]="4ed484c87ee4d0fce2733316af8e3cd174bfc639800fcc3de8bc"
    [AARCH64_SHA256]+="6b2ec2331421"
)

#############################################################
# Rootfs profile variables
#############################################################

# "minimal" profile details
declare -A RFS_MINIMAL=(
    [NAME]="boottime-rootfs.ext4"
    [SIZE]="30M"
    [FS]="ext4"
    [CUST]="--install ca-certificates \
      --install curl \
      --install iperf3 \
      --install iproute2 \
      --install iptables \
      --install openrc \
      --install openssh-server \
      --install util-linux \
      --link agetty:/etc/init.d/agetty.ttyS0 \
      --run-command 'echo ttyS0 >/etc/securetty' \
      --run-command 'rc-update add agetty.ttyS0 default' \
      --run-command 'rc-update add devfs boot' \
      --run-command 'rc-update add procfs boot' \
      --run-command 'rc-update add sysfs boot' \
      --root-password password:'root' \
      --password-crypto sha512"
)

# "ubuntu" profile details
declare -A RFS_UBUNTU=(
    [NAME]="bionic.rootfs.ext4"
    [SIZE]="825M"
    [FS]="ext4"
    [CUST]="--root-password password:'root' \
      --password-crypto sha512"
)

# "ubuntu_with_ssh" profile details
declare -A RFS_UBUNTU_WITH_SSH=(
    [NAME]="bionic.rootfs.ext4"
    [SIZE]="825M"
    [FS]="ext4"
    [CUST]="--install openssh-server \
      --append-line /etc/ssh/sshd_config:'PermitRootLogin yes' \
      --root-password password:'root' \
      --password-crypto sha512"
)

# Global options received by $0
# These options are not command-specific, so we store them as global vars
OPT_UNATTENDED=false

# Load common functions
#
if [[ ! -f "${FC_TOOLS_DIR}/functions" ]]; then
    echo "Unable to find ${FC_TOOLS_DIR}/functions lib.  Aborting."
    exit 1
else
    source "${FC_TOOLS_DIR}/functions"
fi

# `$0 help`
# Show the detailed rfstool usage information.
#
cmd_help() {
    echo ""
    echo "Firecracker $(basename $0)"
    echo "Usage: $(basename $0) [<args>] <command> [<command args>]"
    echo ""
    echo "Global arguments"
    echo "    -y, --unattended         Run unattended. Assume the user would always"
    echo "                             answer \"yes\" to any confirmation prompt."
    echo ""
    echo "Available commands:"
    echo ""
    echo "    build [minimal|ubuntu|ubuntu_with_ssh]"
    echo "        Build a Firecracker rootfs file."
    echo ""
    echo "        The architecture of the host machine determines"
    echo "        the rootfs architecture."
    echo ""
    echo "            On x86_64  -> an x86_64 rootfs will be built"
    echo "            On aarch64 -> an aarch64 rootfs will be built"
    echo ""
    echo "    shell [--privileged]"
    echo "        Launch the rfs container and open an interactive BASH shell."
    echo "        -p, --privileged    Run the container as root, in privileged mode."
    echo "                            Allows the running of custom libguestfs commands"
    echo ""
    echo "    help"
    echo "        Display this help message."
    echo ""
}

# `$0 build` - build Firecracker rootfs
# Please see `$0 help` for more information.
#
cmd_build() {

    # By default, we build minimal rootfs profile
    profile="minimal"

    # Parse any command line args.
    while [ $# -gt 0 ]; do
        case "$1" in
            "-h"|"--help")      { cmd_help; exit 1;  } ;;
            "minimal")          { profile="minimal"; } ;;
            "ubuntu")           { profile="ubuntu";  } ;;
            "ubuntu_with_ssh")  { profile="ubuntu_with_ssh";  } ;;
            *)
                die "Unknown argument: $1. Please use --help for help."
            ;;
        esac
        shift
    done

    # Create local image store
    local img_local="$FC_IMAGES_DIR/local/${HOSTTYPE}/${profile}/fsfiles"
    if [[ ! -d $img_local ]]; then
     say "Creating local img directory: $img_local"
     mkdir -p "$img_local" || die "Cannot create local img store. Aborting"
    fi

    say "Starting rootfs ${profile} build ..."

    # Check prerequisites
    ensure_ctr
    ensure_build_dir

    # The rootfs build is a combination of OS + profile
    case "${profile}" in
        "minimal")          { build_rootfs minimal alpine; } ;;
        "ubuntu")           { build_rootfs ubuntu ubuntu_bionic; } ;;
        "ubuntu_with_ssh")  { build_rootfs ubuntu_with_ssh ubuntu_bionic; } ;;
        *)
            die "Unknown argument: $1. Please use --help for help."
    esac
}

# Build the rootfs.  Takes an OS and a profile name and constructs
# the rootfs system. The profile must match the intended OS, since commands
# can be OS specific.
# Args:
#   $1 profile
#   $2 os
# Example `build_rootfs minimal alpine`
#
build_rootfs() {

    # check we've called the function correctly.
    [ "$#" -ne 2 ] && die "Incorrect number of arguments supplied"

    local profile="${1}"
    local os="${2}"

    # get OS details based on pre-defined array
    # for example, RFS_ALPINE containing package details
    local package=RFS_${os^^}[PACKAGE]
    local sha256=RFS_${os^^}[${HOSTTYPE^^}_SHA256]
    local url=RFS_${os^^}[URL]

    # check we have values from the OS array
    [[ -z ${!package} || \
       -z ${!sha256} || \
       -z ${!url} ]] \
    && die "Missing OS details. Check the OS data details"

    # get profile details based on pre-defined array
    # for example, RFS_MINIMAL containing profile details
    local rootfs_name=RFS_${profile^^}[NAME]
    local rootfs_size=RFS_${profile^^}[SIZE]
    local rootfs_fs=RFS_${profile^^}[FS]
    local rootfs_cust=RFS_${profile^^}[CUST]

    # check we have values from the profile array
    [[ -z ${!rootfs_name} || \
       -z ${!rootfs_size} || \
       -z ${!rootfs_fs}  || \
       -z ${!rootfs_cust} ]] \
    && die "Missing profile details. Check the profile data details."

    # path to our rootfs under our architecture dir
    local rootfs_path="${profile}/fsfiles/${!rootfs_name}"

    # Commands as strings that we pass to the ctr
    #
    # only fetch our distribution package if we haven't before
    local check_for_package="if \
        [[ ! -f ${CTR_MICROVM_IMAGES_DIR}/local/${!package} ]]; then \
           wget --no-verbose --show-progress ${!url} \
           --output-document=${CTR_MICROVM_IMAGES_DIR}/local/${!package}; \
        fi;"

    # check our distribution package matches our sha256 value
    local checksum_package="echo ${!sha256} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${!package} \
        | sha256sum --check --quiet"

    # if we have an xz file, decompress it
    local extract_package="if \
        [[ ${!package} = *.xz ]]; then \
          unxz --decompress --keep --force \
          ${CTR_MICROVM_IMAGES_DIR}/local/${!package}; \
        fi"

    # use virt-make-fs to create a rootfs file from a distribution
    # file system or cloud image package
    # see http://libguestfs.org/virt-make-fs.1.html
    local make_filesystem="virt-make-fs \
        --size=${!rootfs_size} \
        --type=${!rootfs_fs} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${!package%.xz} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${rootfs_path}"

    # run the OS customization steps. The command is split, 
    # the rootfs file being defined here, whilst the rest of the customization 
    # flags are defined in the profile array
    local customize_os="virt-customize \
        -a ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${rootfs_path} \
        ${!rootfs_cust}"

    # Run the rootfs build process inside the container.
    # We don't need any special privileges for the build phase, so we run the
    # container as the current user/group.
    run_ctr \
        --user "$(id -u):$(id -g)" \
        --workdir "$CTR_FC_ROOT_DIR" \
        -- \
        bash -c \
        "${check_for_package} ${checksum_package} \
         && ${extract_package} \
         && ${make_filesystem} \
         && ${customize_os}"

    ret=$?

    # If the build was successful, notify user of rootfs location
    [ $ret -eq 0 ] && {
        say "${profile^} rootfs built and available at:" \
            "$img_local/${!rootfs_name}"
    }

    return $ret
}

main "$@"
