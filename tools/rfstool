#!/usr/bin/env bash

# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Firecracker rfstool
#
# Use this script to build a rootfs file for testing Firecracker.
#
# TL;DR
# Make sure you have Docker installed and properly configured
# (http://docker.com). Then,
#   building: `./rfstool build`
#     Then find the rootfs file under
#     build/img/local/${HOSTTYPE}/minimal/fsfiles, where HOSTTYPE is the bash
#     variable specifying your host architecture.
#
# Building is done inside a Docker container. Please make sure
# you have Docker up and running on your system (see http:/docker.com) and your
# user has permission to run Docker containers.
#
# The Firecracker sources dir will be bind-mounted inside the development
# container (under /firecracker) and any files generated by the build process
# will show up under the build/img/local/${HOSTTYPE} dir.
#
# By default, all rfstool commands run the container transparently, removing
# it after the command completes. Any persisting files will be stored under
# build/.
#
# Building:
#   Run `./rfstool build`.
#
# Additional information:
#   Run `./rfstool help`.
#
# TODO:
#   - minimal_with_initrd build
#   - ubuntu build
#   - ubuntu_with_ssh build
#   - all build

# Rootfs build container image (name:tag)
# This should be updated whenever we upgrade the rootfs build container.
RFSCTR_IMAGE="fcuvm/rfs:v01"

# Naming things is hard
MY_NAME="Firecracker $(basename "$0")"

# Full path to the Firecracker tools dir on the host.
FC_TOOLS_DIR=$(cd "$(dirname "$0")" && pwd)

# Full path to the Firecracker sources dir on the host.
FC_ROOT_DIR=$(cd "${FC_TOOLS_DIR}/.." && pwd)

# Full path to the build dir on the host.
FC_BUILD_DIR="${FC_ROOT_DIR}/build"

# Full path to the img dir on the host.
FC_IMAGES_DIR="${FC_BUILD_DIR}/img"

# Full path to the Firecracker sources dir, as bind-mounted in the container.
CTR_FC_ROOT_DIR="/firecracker"

# Full path to the build dir, as bind-mounted in the container.
CTR_FC_BUILD_DIR="${CTR_FC_ROOT_DIR}/build"

# Full path to the microVM images cache dir
CTR_MICROVM_IMAGES_DIR="${CTR_FC_BUILD_DIR}/img"

# Rootfs Alpine version
RFS_ALPINE_VERS="3.8.1"

# Alpine CDN url
RFS_ALPINE_ORIGIN="http://dl-cdn.alpinelinux.org"

# Rootfs Alpine x86_64 package name, url locations, and sha256.
RFS_ALPINE_X86_64_GZ="alpine-minirootfs-${RFS_ALPINE_VERS}-x86_64.tar.gz"
RFS_ALPINE_X86_64_URL="${RFS_ALPINE_ORIGIN}"
RFS_ALPINE_X86_64_URL+="/alpine/v${RFS_ALPINE_VERS%.*}/releases/x86_64/"
RFS_ALPINE_X86_64_URL+="/${RFS_ALPINE_X86_64_GZ}"
RFS_ALPINE_X86_64_SHA256="ad753d802048fa902e4d8b35cc53656de8ed0e6d082246089a"
RFS_ALPINE_X86_64_SHA256+="11a86014b0f1a5"

# Rootfs Alpine aarch64 package name, url location, and sha256.
RFS_ALPINE_AARCH64_GZ="alpine-minirootfs-${RFS_ALPINE_VERS}-aarch64.tar.gz"
RFS_ALPINE_AARCH64_URL="${RFS_ALPINE_ORIGIN}"
RFS_ALPINE_AARCH64_URL+="/alpine/v${RFS_ALPINE_VERS%.*}/releases/aarch64/"
RFS_ALPINE_AARCH64_URL+="/${RFS_ALPINE_AARCH64_GZ}"
RFS_ALPINE_AARCH64_SHA256="425be487ecc4bd0333fd84ec8c6c4b971a32446be76df26e7"
RFS_ALPINE_AARCH64_SHA256+="add04be95987fa8"

# Send a decorated message to stdout, followed by a new line
#
say() {
    [ -t 1 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 2)[$MY_NAME]$(tput sgr0) $*" \
        || echo "[$MY_NAME] $*"
}

# Send a decorated message to stdout, without a trailing new line
#
say_noln() {
    [ -t 1 ] && [ -n "$TERM" ] \
        && echo -n "$(tput setaf 2)[$MY_NAME]$(tput sgr0) $*" \
        || echo "[$MY_NAME] $*"
}

# Send a text message to stderr
#
say_err() {
    [ -t 2 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 1)[$MY_NAME] $*$(tput sgr0)" 1>&2 \
        || echo "[$MY_NAME] $*" 1>&2
}

# Send a warning-highlighted text to stdout
say_warn() {
    [ -t 1 ] && [ -n "$TERM" ] \
        && echo "$(tput setaf 3)[$MY_NAME] $*$(tput sgr0)" \
        || echo "[$MY_NAME] $*"
}

# Exit with an error message and (optional) code
# Usage: die [-c <error code>] <error message>
#
die() {
    code=1
    [[ "$1" = "-c" ]] && {
        code="$2"
        shift 2
    }
    say_err "$@"
    exit $code
}

# Exit with an error message if the last exit code is not 0
#
ok_or_die() {
    code=$?
    [[ $code -eq 0 ]] || die -c $code "$@"
}

# Check if Docker is available and exit if it's not.
# Upon returning from this call, the caller can be certain Docker is available.
#
ensure_docker() {
    NEWLINE=$'\n'
    output=$(which docker 2>&1)
    ok_or_die "Docker not found. Aborting." \
        "Please make sure you have Docker (http://docker.com) installed" \
        "and properly configured.${NEWLINE}" \
        "Error: $?, command output: ${output}"

    output=$(docker ps 2>&1)
    ok_or_die "Error accessing Docker. Please make sure the Docker daemon" \
        "is running and that you are part of the docker group.${NEWLINE}" \
        "Error: $?, command output: ${output}${NEWLINE}" \
        "For more information, see" \
        "https://docs.docker.com/install/linux/linux-postinstall/"
}

# Attempt to download our Docker image. Exit if that fails.
# Upon returning from this call, the caller can be certain our Docker image is
# available on this system.
#
ensure_rfsctr() {

    # We depend on having Docker present.
    ensure_docker

    # Check if we have the container image available locally. Attempt to
    # download it, if we don't.
    [[ $(docker images -q "$RFSCTR_IMAGE" | wc -l) -gt 0 ]] || {
        say "About to pull docker image $RFSCTR_IMAGE"
        get_user_confirmation || die "Aborted."

        docker pull "${RFSCTR_IMAGE}"

        ok_or_die "Error pulling docker image. Aborting."
    }
}

# Check if /dev/kvm exists. Exit if it doesn't.
# Upon returning from this call, the caller can be certain /dev/kvm is
# available.
#
ensure_kvm() {
    [[ -c /dev/kvm ]] || die "/dev/kvm not found. Aborting."
}

# Make sure the build/ dirs are available. Exit if we can't create them.
# Upon returning from this call, the caller can be certain the build/ dirs exist.
#
ensure_build_dir() {
    for dir in "$FC_BUILD_DIR"; do
        mkdir -p "$dir" || die "Error: cannot create dir $dir"
        [ -x "$dir" ] && [ -w "$dir" ] || \
            {
                say "Wrong permissions for $dir. Attempting to fix them ..."
                chmod +x+w "$dir"
            } || \
            die "Error: wrong permissions for $dir. Should be +x+w"
    done
}


# Prompt the user for confirmation before proceeding.
# Args:
#   $1  prompt text.
#       Default: Continue? (y/n)
#   $2  confirmation input.
#       Default: y
# Return:
#   exit code 0 for successful confirmation
#   exit code != 0 if the user declined
#
get_user_confirmation() {

    # Pass if running unattended
    [[ "$OPT_UNATTENDED" = true ]] && return 0

    # Fail if STDIN is not a terminal (there's no user to confirm anything)
    [[ -t 0 ]] || return 1

    # Otherwise, ask the user
    #
    msg=$([ -n "$1" ] && echo -n "$1" || echo -n "Continue? (y/n) ")
    yes=$([ -n "$2" ] && echo -n "$2" || echo -n "y")
    say_noln "$msg"
    read c && [ "$c" = "$yes" ] && return 0
    return 1
}


# Helper function to run the dev container.
# Usage: run_rfsctr <docker args> -- <container args>
# Example: run_rfsctr --privileged -- bash -c "echo 'hello world'"
#
run_rfsctr() {
    docker_args=()
    ctr_args=()
    docker_args_done=false
    while [[ $# -gt 0 ]]; do
        [[ "$1" = "--" ]] && {
            docker_args_done=true
            shift
            continue
        }
        [[ $docker_args_done = true ]] && ctr_args+=("$1") || docker_args+=("$1")
        shift
    done

    # If we're running in a terminal, pass the terminal to Docker and run
    # the container interactively
    [[ -t 0 ]] && docker_args+=("-i")
    [[ -t 1 ]] && docker_args+=("-t")

    # Try to pass these environments from host into container for network proxies
    proxies=(http_proxy HTTP_PROXY https_proxy HTTPS_PROXY no_proxy NO_PROXY)
    for i in "${proxies[@]}"; do
        if [[ ! -z ${!i} ]]; then
            docker_args+=("--env") && docker_args+=("$i=${!i}")
        fi
    done

    # Finally, run the dev container
    # Use 'z' on the --volume parameter for docker to automatically relabel the
    # content and allow sharing between containers.
    docker run "${docker_args[@]}" \
        --rm \
        --volume /dev:/dev \
        --volume "$FC_ROOT_DIR:$CTR_FC_ROOT_DIR:z" \
        --env OPT_LOCAL_IMAGES_PATH="$(dirname "$CTR_MICROVM_IMAGES_DIR")" \
        --env PYTHONDONTWRITEBYTECODE=1 \
        "$RFSCTR_IMAGE" "${ctr_args[@]}"
}

# `$0 help`
# Show the detailed rfstool usage information.
#
cmd_help() {
    echo ""
    echo "Firecracker $(basename $0)"
    echo "Usage: $(basename $0) <command> [<command args>]"
    echo ""
    echo "Available commands:"
    echo ""
    echo "    build [minimal]"
    echo "        Build a Firecracker rootfs file."
    echo ""
    echo "        The architecture of the host machine determines"
    echo "        the rootfs architecture."
    echo ""
    echo "            On x86_64  -> an x86_64 rootfs will be built"
    echo "            On aarch64 -> an aarch64 rootfs will be built"
    echo ""
    echo "    help"
    echo "        Display this help message."
    echo ""
}

# `$0 build` - build Firecracker rootfs
# Please see `$0 help` for more information.
#
cmd_build() {

    # By default, we build minimal rootfs
    friendly_name="minimal"

    # Parse any command line args.
    while [ $# -gt 0 ]; do
        case "$1" in
            "-h"|"--help")  { cmd_help; exit 1; } ;;
            "minimal")      { friendly_name="minimal";  } ;;
            *)
                die "Unknown argument: $1. Please use --help for help."
            ;;
        esac
        shift
    done

    # Create local image store
    local img_local="$FC_IMAGES_DIR/local/${HOSTTYPE}/${friendly_name}/fsfiles"
    if [[ ! -d $img_local ]]; then
     say "Creating local img directory: $img_local"
     mkdir -p "$img_local" || die "Cannot create local img store. Aborting"
    fi

    say "Starting rootfs ${friendly_name} build ..."

    # Check prerequisites
    ensure_rfsctr
    ensure_build_dir

    case "${friendly_name}" in
        "minimal") { build_minimal }; };;
        *)
            die "Unknown argument: $1. Please use --help for help."
    esac

}

# `$0 build` - build Firecracker "minimal" rootfs
# Please see `$0 help` for more information.
#
build_minimal() {

    # get package details based on bash HOSTTYPE variable
    # virt-customize will refuse to run commands on rootfs filesystems
    # where the guest architecture differs from the running host,
    # so this value cannot be forced.
    case "${HOSTTYPE}" in
        x86_64)  {
                     package="${RFS_ALPINE_X86_64_GZ}"
                     url="${RFS_ALPINE_X86_64_URL}"
                     sha256_string="${RFS_ALPINE_X86_64_SHA256}"
                 } ;;
        aarch64) {
                    package="${RFS_ALPINE_AARCH64_GZ}"
                    url="${RFS_ALPINE_AARCH64_URL}"
                    sha256_string="${RFS_ALPINE_AARCH64_SHA256}"
                 } ;;
         *)
            die "Unknown architecture: ${HOSTTYPE}. Please use --help for help."
            ;;
    esac

    # path to our rootfs under our architecture dir
    local min_rootfs="minimal/fsfiles/boottime-rootfs.ext4"

    # Commands as strings that we pass to the rfsctr
    #
    # only fetch our distribution package if we haven't before
    local check_for_package="if \
        [[ ! -f ${CTR_MICROVM_IMAGES_DIR}/local/${package} ]]; then \
            wget --no-verbose ${url} \
	         --output-document=${CTR_MICROVM_IMAGES_DIR}/local/${package}; \
        fi;"

    # check our distribution package matches our sha256 value
    local checksum_package="echo ${sha256_string} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${package} \
        | sha256sum --check --quiet"

    # use virt-make-fs to create a rootfs file from a distribution
    # file system or cloud image package
    # see http://libguestfs.org/virt-make-fs.1.html
    local make_filesystem="virt-make-fs \
        --size=30M \
        --type=ext4 \
        ${CTR_MICROVM_IMAGES_DIR}/local/${package} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${min_rootfs}"

    # customize the rootfs OS, see http://libguestfs.org/virt-customize.1.html
    local customize_os="virt-customize \
        -a ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${min_rootfs} \
        --install ca-certificates \
        --install curl \
        --install iperf3 \
        --install iproute2 \
        --install iptables \
        --install openrc \
        --install openssh-server \
        --install util-linux \
        --link agetty:/etc/init.d/agetty.ttyS0 \
        --run-command 'echo ttyS0 >/etc/securetty' \
        --run-command 'rc-update add agetty.ttyS0 default' \
        --run-command 'rc-update add devfs boot' \
        --run-command 'rc-update add procfs boot' \
        --run-command 'rc-update add sysfs boot' \
        --run-command 'rc-update add local default' \
        --write /etc/local.d/umount.stop:'umount /' \
        --chmod 0700:/etc/local.d/umount.stop \
        --root-password password:'root' \
        --password-crypto sha512"

    # Run the rootfs build process inside the container.
    # We don't need any special privileges for the build phase, so we run the
    # container as the current user/group.
    run_rfsctr \
        --user "$(id -u):$(id -g)" \
        --workdir "$CTR_FC_ROOT_DIR" \
        -- \
        bash -c \
        "${check_for_package} ${checksum_package} \
         && ${make_filesystem} \
         && ${customize_os}"

    ret=$?

    # If the build was successful, notify user of rootfs location
    [ $ret -eq 0 ] && {
        say "Minimal rootfs built and available at:" \
            "$img_local/boottime-rootfs.ext4"
    }

    return $ret
}

main() {

    if [ $# = 0 ]; then
        die "No command provided. Please use \`$0 help\` for help."
    fi

    # Parse main command line args.
    #
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)              { cmd_help; exit 1;     } ;;
            -*)
                die "Unknown arg: $1. Please use \`$0 help\` for help."
            ;;
            *)
                break
            ;;
        esac
        shift
    done

    # $1 is now a command name. Check if it is a valid command and, if so,
    # run it.
    #
    declare -f "cmd_$1" > /dev/null
    ok_or_die "Unknown command: $1. Please use \`$0 help\` for help."

    cmd=cmd_$1
    shift

    # $@ is now a list of command-specific args
    #
    $cmd "$@"
}

main "$@"
