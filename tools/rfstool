#!/usr/bin/env bash

# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Firecracker rfstool
#
# Use this script to build a rootfs file for testing Firecracker.
#
# TL;DR
# Make sure you have Docker installed and properly configured
# (http://docker.com). Then,
#   building: `./rfstool build`
#     Then find the rootfs file under
#     build/img/local/${HOSTTYPE}/minimal/fsfiles, where HOSTTYPE is the bash
#     variable specifying your host architecture.
#
# Building is done inside a Docker container. Please make sure
# you have Docker up and running on your system (see http:/docker.com) and your
# user has permission to run Docker containers.
#
# The Firecracker sources dir will be bind-mounted inside the development
# container (under /firecracker) and any files generated by the build process
# will show up under the build/img/local/${HOSTTYPE} dir.
#
# By default, all rfstool commands run the container transparently, removing
# it after the command completes. Any persisting files will be stored under
# build/.
#
# Building:
#   Run `./rfstool build`.
#
# Additional information:
#   Run `./rfstool help`.
#
# TODO:
#   - minimal_with_initrd build
#   - ubuntu build
#   - ubuntu_with_ssh build
#   - all build

# Rootfs build container image (name:tag)
# This should be updated whenever we upgrade the rootfs build container.
CTR_IMAGE="fcuvm/rfs:v01"

# Naming things is hard
MY_NAME="Firecracker $(basename "$0")"

# Full path to the Firecracker tools dir on the host.
FC_TOOLS_DIR=$(cd "$(dirname "$0")" && pwd)

# Full path to the Firecracker sources dir on the host.
FC_ROOT_DIR=$(cd "${FC_TOOLS_DIR}/.." && pwd)

# Full path to the build dir on the host.
FC_BUILD_DIR="${FC_ROOT_DIR}/build"

# Full path to the img dir on the host.
FC_IMAGES_DIR="${FC_BUILD_DIR}/img"

# Full path to the Firecracker sources dir, as bind-mounted in the container.
CTR_FC_ROOT_DIR="/firecracker"

# Full path to the build dir, as bind-mounted in the container.
CTR_FC_BUILD_DIR="${CTR_FC_ROOT_DIR}/build"

# Full path to the microVM images cache dir
CTR_MICROVM_IMAGES_DIR="${CTR_FC_BUILD_DIR}/img"

# Rootfs Alpine version
RFS_ALPINE_VERS="3.8.1"

# Alpine CDN url
RFS_ALPINE_ORIGIN="http://dl-cdn.alpinelinux.org"

# Rootfs Alpine package name, url location, and shas.
RFS_ALPINE_GZ="alpine-minirootfs-${RFS_ALPINE_VERS}-${HOSTTYPE}.tar.gz"
RFS_ALPINE_URL="${RFS_ALPINE_ORIGIN}"
RFS_ALPINE_URL+="/alpine/v${RFS_ALPINE_VERS%.*}/releases/${HOSTTYPE}/"
RFS_ALPINE_URL+="/${RFS_ALPINE_GZ}"

RFS_ALPINE_X86_64_SHA256="ad753d802048fa902e4d8b35cc53656de8ed0e6d082246089a"
RFS_ALPINE_X86_64_SHA256+="11a86014b0f1a5"

RFS_ALPINE_AARCH64_SHA256="425be487ecc4bd0333fd84ec8c6c4b971a32446be76df26e7"
RFS_ALPINE_AARCH64_SHA256+="add04be95987fa8"

# Global options received by $0
# These options are not command-specific, so we store them as global vars
OPT_UNATTENDED=false

# Load common functions
#
if [[ ! -f "${FC_TOOLS_DIR}/functions" ]]; then
   echo "Unable to find ${FC_TOOLS_DIR}/functions lib.  Aborting."
   exit 1
else
   source "${FC_TOOLS_DIR}/functions"
fi

# `$0 help`
# Show the detailed rfstool usage information.
#
cmd_help() {
    echo ""
    echo "Firecracker $(basename $0)"
    echo "Usage: $(basename $0) [<args>] <command> [<command args>]"
    echo ""
    echo "Global arguments"
    echo "    -y, --unattended         Run unattended. Assume the user would always"
    echo "                             answer \"yes\" to any confirmation prompt."
    echo ""
    echo "Available commands:"
    echo ""
    echo "    build [minimal]"
    echo "        Build a Firecracker rootfs file."
    echo ""
    echo "        The architecture of the host machine determines"
    echo "        the rootfs architecture."
    echo ""
    echo "            On x86_64  -> an x86_64 rootfs will be built"
    echo "            On aarch64 -> an aarch64 rootfs will be built"

    echo ""
    echo "    shell [--privileged]"
    echo "        Launch the rfs container and open an interactive BASH shell."
    echo "        -p, --privileged    Run the container as root, in privileged mode."
    echo "                            Allows the running of custom libguestfs commands"
    echo ""
    echo "    help"
    echo "        Display this help message."
    echo ""
}

# `$0 build` - build Firecracker rootfs
# Please see `$0 help` for more information.
#
cmd_build() {

    # By default, we build minimal rootfs
    friendly_name="minimal"

    # Parse any command line args.
    while [ $# -gt 0 ]; do
        case "$1" in
            "-h"|"--help")  { cmd_help; exit 1; } ;;
            "minimal")      { friendly_name="minimal";  } ;;
            *)
                die "Unknown argument: $1. Please use --help for help."
            ;;
        esac
        shift
    done

    # Create local image store
    local img_local="$FC_IMAGES_DIR/local/${HOSTTYPE}/${friendly_name}/fsfiles"
    if [[ ! -d $img_local ]]; then
     say "Creating local img directory: $img_local"
     mkdir -p "$img_local" || die "Cannot create local img store. Aborting"
    fi

    say "Starting rootfs ${friendly_name} build ..."

    # Check prerequisites
    ensure_ctr
    ensure_build_dir

    case "${friendly_name}" in
        "minimal") { build_minimal }; };;
        *)
            die "Unknown argument: $1. Please use --help for help."
    esac

}

# `$0 build` - build Firecracker "minimal" rootfs
# Please see `$0 help` for more information.
#
build_minimal() {

    # get sha details based on bash HOSTTYPE variable
    case "${HOSTTYPE}" in
        x86_64)  {
		   sha256_string="${RFS_ALPINE_X86_64_SHA256}"
                 } ;;
        aarch64) {
		   sha256_string="${RFS_ALPINE_AARCH64_SHA256}"
                 } ;;
         *)
            die "Unknown architecture: ${HOSTTYPE}. Please use --help for help."
            ;;
    esac

    # path to our rootfs under our architecture dir
    local min_rootfs="minimal/fsfiles/boottime-rootfs.ext4"

    # Commands as strings that we pass to the rfsctr
    #
    # only fetch our distribution package if we haven't before
    local check_for_package="if \
        [[ ! -f ${CTR_MICROVM_IMAGES_DIR}/local/${RFS_ALPINE_GZ} ]]; then \
	 wget --no-verbose ${RFS_ALPINE_URL} \
	 --output-document=${CTR_MICROVM_IMAGES_DIR}/local/${RFS_ALPINE_GZ}; \
        fi;"

    # check our distribution package matches our sha256 value
    local checksum_package="echo ${sha256_string} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${RFS_ALPINE_GZ} \
        | sha256sum --check --quiet"

    # use virt-make-fs to create a rootfs file from a distribution
    # file system or cloud image package
    # see http://libguestfs.org/virt-make-fs.1.html
    local make_filesystem="virt-make-fs \
        --size=30M \
        --type=ext4 \
        ${CTR_MICROVM_IMAGES_DIR}/local/${RFS_ALPINE_GZ} \
        ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${min_rootfs}"

    # customize the rootfs OS, see http://libguestfs.org/virt-customize.1.html
    local customize_os="virt-customize \
        -a ${CTR_MICROVM_IMAGES_DIR}/local/${HOSTTYPE}/${min_rootfs} \
        --install ca-certificates \
        --install curl \
        --install iperf3 \
        --install iproute2 \
        --install iptables \
        --install openrc \
        --install openssh-server \
        --install util-linux \
        --link agetty:/etc/init.d/agetty.ttyS0 \
        --run-command 'echo ttyS0 >/etc/securetty' \
        --run-command 'rc-update add agetty.ttyS0 default' \
        --run-command 'rc-update add devfs boot' \
        --run-command 'rc-update add procfs boot' \
        --run-command 'rc-update add sysfs boot' \
        --root-password password:'root' \
        --password-crypto sha512"

    # Run the rootfs build process inside the container.
    # We don't need any special privileges for the build phase, so we run the
    # container as the current user/group.
    run_ctr \
        --user "$(id -u):$(id -g)" \
        --workdir "$CTR_FC_ROOT_DIR" \
        -- \
        bash -c \
        "${check_for_package} ${checksum_package} \
         && ${make_filesystem} \
         && ${customize_os}"

    ret=$?

    # If the build was successful, notify user of rootfs location
    [ $ret -eq 0 ] && {
        say "Minimal rootfs built and available at:" \
            "$img_local/boottime-rootfs.ext4"
    }

    return $ret
}

main "$@"
